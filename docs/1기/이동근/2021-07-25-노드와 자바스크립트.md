---
title: "노드와 자바스크립트"
author: 이동근
date: "2021-07-25"
---

# 노드와 자바스크립트

## 자바스크립트
최근에 웹은 자기자신을 홍보하는 용도로 많이사용되어지고 있습니다. 초기 웹과 비교해서 현재 많은 발전이 이루어져 왔습니다. 

웹사이트를 만들고 싶다면 반드시 배워야 하는 프로그래밍 언어라고 할 수 있습니다.

2015년에는 기존에 있는 인식을 뒤집을 정도로 현재 인기가 많이 사용되어 지고 있습니다. 그래서 점점 범용적인 부분으로 활용이 많아지게 되었습니다.

세미콜론을 통해 문장을 구분 할 수 있다.
처음에는 세미콜론을 의식적으로 사용하자
> 개발자들 사이에서 세미콜론을 쓰지말자 그냥 명시적으로 사용하자 의견 논란이 있음

### 코멘트 - 주석처리
'//' 코드에 인식하지 안도록 하는 것 - 줄바꿈을 하면 풀리기 때문에
'/*   * /' 별과 별 사이에 코멘트를 적으면 줄바꿈이 일어나더라도 괜찮다.

### 추상화
복잡한 것들을 목적에 맞게 단순화 하는 것

변수 선언 var let const

### 작명가이드
camelCase
변수명에는 띄어쓰기가 불가능 하기 때문에 띄어쓰기를 대신 할 무언가가 필요합니다. 그 중 하나가 camelCase라는 것이다. 첫 번째 글자는 소문자로 하고, 띄어쓰기가 있는 각 단어의 첫 문자를 대문자로 표시

예시 
```js
let bad_variable_name; //비추천 방식 
let goodVariableName;  // 추천 방식
```

### 함수
function 함수이름() {작성할 명령들을 작성}

console.log(파라미터) - 한국어로 매개변수

and연산 &&
or연산 ||
not연산 !

### typeof 연산자' - 파이썬의  type 함수
typeof 값 값을 확인한 후에 문자열로 리턴함
typeof도 연산자이기 때문에 다른 연산자와 같이 사용할때 주의해서 사용해야 한다.

### 형변환 시에 
String, Number, Boolean

falsy = 빈문자, 0, NaN - 빈문자 불린 값

### 증가 감소 연산자
x = x+ 1
x += 1
x++

x = x -1
x -=1
x--

### if문
```js
if (조건){
실행문;
} else if (조건){
실행문
} else {
실행문} 
```
### switch 문
```js
switch (비교할 값) {
  case 조건값_1:
    동작부분;
    break;
  case 조건값_2:
    동작부분;
    break;
    .
    .
    .
    .
  default:
    동작부분;
} 

```
switch 어떤 대상과 조건값이 일치하는지를 확인하고 그 결과에 따라 다른 동작이 필요한 경우 사용
switch문은 break문을 만나기 전까지 계속 반복해서 조건문을 진행한다.

### if문과 switch문
어떤 대상과 조건값이 일치하는 가를 확인 하는 경우에는 if문으로도 충분히 가능하다. 그럼 두 구문의 차이는 어떤 것일까?

if문을 사용하고자 할때에는 더욱 넓은 범위를 만족하는 조건을 사용해야 할 때 좋고 **특정한 값**에 일치하고자 할때에는 switch문을 사용하는 것이 더욱 좋다.

한 가지 주의할 점은 조건식에서 등호를 반드식 3개를 입력해 주어야 한다는 점이다. switch문은 암시적 형 변환을 허용하지 않기 때문입니다.

쉽게 이야기 하자면, 조건문을 걸때 문자열 2,와 숫자열2를 넣게 되면 switch문을 실행 했을 때에는 바로 default문이 실행이 되고,

if문을 사용해서 조건을 걸 경우 등호를 2개를 쓰면 문자열, 숫자열 구분이 없어지고, 등호를 3개를 쓰게 되면 엄격하게 구분을 하기 때문에 등호는 무조건 3개를 사용한다.


### for문
```js
for추가동 (초기화부분; 조건부분; 추가동작부분) {
  동작부분
}
```

```js
for (let i =1; i <10; i++) {
  console.log(`${i} 코드잇 최고!`)
}
```

초기화 부분은 단 한번만 실행이 된다.
for문의 i는 로컬변수라서 for문 바깥에서 사용하려고 하면 오류가 난다.
추가 동작 부분을 꼭 채울 필요는 없다.
초기화 부분을 꼭 채울 필요는 없다. 하지만 ;은 생략해서는 안된다.
>let i = 1; 
for (; i <= 10; i++) {
  console.log(`${i} 코드잇 최고!`);
}

반드시 for문의 소괄호 안에는 세미콜론이 두 개가 들어가 있어야 한다.

### 객체
자바스크립트의 모든 것이 다 객체다.
{
brandName : '코드잇',
bornYear: 2017,
isVeryNice: true,
worstCourse: null
}
key(Property Name) - 문자열 따옴표를 생략하더라도 문자열을 자동으로 인식
- 만약 따옴표를 붙히지 않으면 첫 번째 글자는 반드시, 문자 밑줄 달러 기호 중 하나로 시작
- 띄어쓰기 금지!
- 하이픈 금지!
: brandName,bornTear, isVeryNice, worstCourse
value(Property Value): '코드잇', 2017, true, null

key와 value 값을 합쳐서 property 라고 합니다.

let codeit = {
  'name': '코드잇',
  'bornYear' : 2017,
  'isVeryCourse': true,
  'worstCourse': null,
  'bestCourse' : {
    'title': '자바스크립트 프로그래밍 기초',
    'language' : 'JavaScript'
  }
};

객체 접근하기위해서는
**점 표기법** : 가장 기본적이고
console.log(codeit.bornYear)
- 따옴표를 생략하는 객체에 접근 하지 못한다.
**대괄호 표기법**
console.log(codeit['name'])

만약 존재하지 않은 프로퍼티에 접근하려고 하면 undefined가 나옵니다.

연관성 있는 여러 함수들을 묶는다. 이때도 객체를 사용하면 된다.

### 메서드
어떤 객체의 고유한 동작으로써 함수에 의미를 부여할 수 있다.

### for in 문의 순서
for in 반복문이 실행될 때 따로 정해진 순서 없이 객체에 추가한 순서를 따라서 반복문이 수행된걸 볼 수 있습니다.

정수형 key값을 먼저 정렬한 뒤에 나머지 프로퍼티들을 추가한 순서대로 정렬하는 특징이 있다.
그래서 정수형 프로퍼티 네임은 가급적이면 사용하지 않는 것을 추천한다.

#### member = ['가','나','다','라','마']

### 배열
#### 배열 메소드
#### 1. splice(startIndex, deleteCount, item)
배열의 데이터 삭제하기 객체를 삭제 할때 처럼 delete를 사용하게 되면 배열의 데이터가 삭제는 되지만 empty라는 부분이 남게 된다. 그래서 이를 방지하기 위해 **splice**를 사용한다.

splice는 전달된 값 이후의 모든 값을 지우게 된다.
members.splice(1)이라고 하면 ['가'] 출력이 된다.
그래서 splice('삭제를 시작할 인덱스', '몇개를 지울것인지','삭제할 자리에 추가할 값')형식으로 사용하면 된다.

사용예시
배열의 첫 요소를 삭제
members.splice(0,1)
배열의 마지막 요소를 삭제
members.splice(members.length-1,1)
배열의 첫 요소로 값 추가
members.splice(0,0, 'NiceCodeit');
배열의 마지막 요소로 값 추가
members.splice(memberslength,0,'Hicodeit')

#### 2. shift - 배열의 첫 요소를 삭제
members.shift()
맨 앞의 값을 삭제하고 배열을 뒤로 미룬다.

#### 3.pop() - 배열의 마지막 요소를 삭제
members.pop()

#### 4. unshift 배열의 첫 요소로 값 추가
members.unshift()

#### 5. push() - 배열의 마지막 요소로 값을 추가
members.push()

### for .... of 반복문

for (변수 of 배열) {
  동작부분;
}

#### for in, for of 반복문의 차이

for in - 객체에서 key를 뽑아서 사용
for of - 배열에서 각각 value를 뽑아서 사용한다.

### 기본형과 참조형
기본형(Primitive Type) 
- Number, String, Boolean, Null, Undefined
- 변수 = 값

참조형 (Reference Type) 
- 객체, 배열
- 변수 = 주소값


변수의 객체값을 할당한 경우에는 객체값이 어딘가에 만들어지고 변수에는 그 주소가 만들어 진다.

let x = {name = '1111'}
let y = x;

y.birt = 2222

이런식으로 만들어 준 뒤 console.log를 x,y를 통해 출력하게 되면 y에 출력을 하더라도 x도 같이 변하게 된다.

변수는 const으로 선언하세요 왜? ----? 좀 더 공부가 필요
const와 let의 큰 차이는 재할당의 가능 여부 이다.

객체는 변수에 주소값이 저장이 된다.
할당연산자는 변수가 가진 주소값이 변경되는 것이 아니기 때문에 객체의 값이 변할 수 도 있다.

#### var
예전에는 var을 사용하기도 했다. 하지만 let과 const와는 다르게 중복선언이 가능하기 때문에 길고 복잡한 코드를 작성할 때 실수를 할 가능성이 커지고, 상황에 따라서는 치명적인 오류가 발생할 수 있습니다.

var는 지역변수의 구분이 함수에만 있기 때문에 if, for, while, switch등 다양한 상황에서 선언한 변수가 자칫, 전역변수의 역할을 하게 될 수 있다는 것이다.

Hoisting이 가능하다. var변수는 함수 스코프를 기준으로 선언되기 때문에 이전에도 변수에 접근이 가능하다.

코드를 짜고 사용함에 있어 혼란을 야기 하는 이 세가지 특성 때문에 현재 var보다는 const와 let이 많이 사용이 되고 있습니다.

## ECMAScript
자바스크립트 표준 명세서
자바스크립트가 발전해 오면서 많은 기능들을 국제 표준화 기구에서 관리합니다. 
그래서 버전 별로 ES숫자(ECMAScript) 
그 중 자바스크립틔 발전에 가장 큰 영향을 끼친 버전이 ES6(2015)이다 이후 ES6+이런식으로 출시된 버전을 표시했다.

>현시점에 사용하기 적합한 범위 내에서 최신 버전의 표준을 준수하는 자바스크립트를 **모던 자바스크립트**라고 합니다.

## JavaScript vs ECMAScript
자바스크립트와 에크마스크립트가 똑같다고 오해하는 경우가 있는데 둘 사이에는 명확한 차이가 있습니다.

- 자바스크립트는 프로그래밍 언어이고, 에크마스크립트는 프로그래밍 언어의 표준입니다. 즉 에크마스크립트는 자바스크립트의 설명서 라고 생각하면 됩니다.
- 자바스크립트는 에크마스크립트를 기반으로 하지만 에크마스크립트에 정의된 내용뿐만 아니라, 다른 부가적인 기능도 있다는 겁니다.

## 데이터 타입의 특징과 종류
자바스크립트는 데이터타입이 유연합니다.
'2' + 3 = '23' 문자열2와 숫자형 3을 더하게 되면 문자형 23이 출력
'2'*3 = 6 문자형'2'와 숫자형 3을 곱하게 되면 숫자형  6이 출력

기본형 - Number, String, Boolean, Null, Undefined, Symbol(다른값과 비교하지 않은 유일한 값을 만들 때), bigint(엄청 큰 숫자를 다룰 때!)
참조형 - object

Symbol - 다른값과 비교하지 않은 유일한 값을 만들때
typeof 함수
typeof null을 하게 되면 'object'
typeof 함수; 를 하게 되면 'function'

> false로 평가되는 값
false, null, undefined, Nan, 0 ' '
그 외 나머지는 True(빈객체, 빈 배열도 true  값)

자바스크립트에서 AND의 연산방식을 할때 오른쪽과 왼쪽을 비교했을때
- 왼쪽값이 truecy하면 오른쪽값을 출력하고, 왼쪽값이 falscy하면 그대로 왼쪽값이 출력이 되었다.

OR연산자
- 왼쪽값이 true면 왼쪽값을 출력, 왼쪽값이 falcy면 오른쪽 값을 출력한다.

> and와 or 연산자의 우선순위를 따지게 되면 and연산자의 순위가 더욱 높다.

즉 3개를 비교하게 된다면
console.log('1111' && 222 || null) === console.log(('1111' && 222) || null)
이런식으로 and연산 먼저 실행 후 or 연산이 실행이 된다.

함수를 만드는 방법
- 함수를 직접적으로 선언해서 쓰는 방법(호이스팅이 가능함) - var
- 함수를 변수로 사용해서 쓰는 방법(호이스팅이 일어나지 않음)

### 기명함수 표현식 
함수 표현식으로 함수를 만들 때에는 선언하는 함수에 이름을 붙혀 줄 수도 있는데요 이름이 있는 함수 표현식, 즉 기명함수 표현식 이라고 부릅니다.
함수표현식으로 함수가 할당된 변수에는 자동으로 name이라는 프로퍼티를 가지게 됩니다.

함수표현식을 작성할때, 함수에 이름을 지정할 수 있다는 점과 특히 이렇게 함수 내에서 함수를 가리켜야 할 때는 꼭 함수 이름을 작성해주는 것이 안전하다는 점. 잘 기억해 두시면 좋을 것 같습니다.

### 즉시실행 함수
```js
function sayHi() {
  console.log('Hi');
}

sayHi()
```
이런식으로 해야 실행이 됬다면,
```js
(function () {
  console.log('Hi!');
})(); 
```
이렇게 소괄호를 묶어준뒤 함수를 실행하는 소괄호를 한 번 더 붙혀주는 방식을 취한다면 함수가 선언된 순간 바로 실행이 됩니다. 이걸 **즉시 실행함수(IIFE)**라고 합니다.
주의할점
즉시 실행 함수는 함수에 이름을 지어주더라도 외부에서 재사용 할 수 없습니다.

그래서 말 그대로 선언과 동시에 실행이 이루어 지기 때문에 일반적으로 **프로그램 초기화 기능에**많이 활용이 됩니다.
```js
(function init() {//프로그램이 실행 될 때 기본적으로 동작할 코드들...})
```

혹은 재사용이 필요 없는, 일회성 동작을 구성할 때 활용하기도 하는데요.

자바스크립트의 함수는 객체로서 사용

다른 함수의 파라미터로 전달 된 함수 **callback 함수**

함수 안에 함수를 넣는 것이 고차함수
```js
function getPriceHi() {
  return function () {
    console.log('Hi');  
 };
};
```
getPrice()(); 이런식으로 고차 함수를 호출 할 수도 있다.

다른 함수의 파라이터가 될 수 도 있고 리턴 값도 될 수 있는 것을 **일급함수** 라고도 한다.

### Arrow Function
- 이름이 있는 변수에 할당을 하거나,
- 함수의 parameter로 들어갈 때  좀더 편하게 사용할 수 있다.
1.
```js
function add1(x,y) {
  return x+y;
}
```
2.
```js
const add2 = (x,y) => {
  return x+y;
}
```
3.
```js
const getCodeit = () => {name : 'Condeit'}
```
3번 처럼 사용하게 되면 중괄호가 함수 선언시에 사용되어지는 중괄호 인줄 알고 오류가 난다. 그래서 그 옆을 소괄호로 묶어주게 되면 오류가 발생하지 않는다.

![](https://images.velog.io/images/eagle5424/post/9ec7f27d-6269-4970-a76c-11fbbee14257/image.png)

이런식으로 function을 선언하지 않더라도 **=>**를 사용하면 function을 만들 수 있다.
```js
const add3 = (x,y) => x+y;
```

화살표 함수 내부에 return만 있는 경우에는 이런식으로 써도 사용이 가능한다.

![](https://images.velog.io/images/eagle5424/post/3a4e38dc-b22c-47c6-917e-5b9e706ff15e/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7,%202021-07-20%2017-50-09.png)

arrow function에는 arguments 객체가 없기 때문에 arguments를 사용하는 함수는 arrow function으로 사용하기 어렵다.

```js
function greeting(name) {
  console.log('Hi my~~~')}

greeting('javascript')
```

소괄호 안의 name = parameter
greeting의 'javascript 는  argument 인자

> #### Arguments 함수내부에서 arguments를 메소드로 받을 수 있다. 그래서 함수 이름을 argument나 변수 이름을 argument로 짓는 것은 피해야 한다.

### Rest Parameter
argument가 유사배열이기 때문에 배열의 메소드 사용불가
argument의 부분만을 사용하기 위해서는 인덱싱이 필요하다

이를 Rest Parameter 문법이 나오게 되었다.
```js
function printArgument(...args) {
  for (const arg of args) {
    console.log(arg);
  }
  console.log('---------------')
}
```
이런식으로 '...'을 붙혀주는 것을 rest 파라미터라고 한다.
...args 이런식으로 rest parameter로 만들어 주게 되면 배열의 메소드를 사용할 수 없는 argument가 배열 메소드의 사용이 가능해 진다.
![](https://images.velog.io/images/eagle5424/post/0e1bbf55-a71b-479c-b98c-6b262a61044d/image.png)
처음에 arguments를 rest parameter로 변형시킨 후에 배열 메소드인 splice를 사용하면 arguments에 잘 적용이 되어진 것을 볼 수 있다.

그리고 Reat parameter는 일반 파라미터와도 같이 사용할 수 있다.
```js
function printRank(first, second, ...others ){
  console.log('코드잇 레이스 최종 결과');
  console.log(`우승 : ${first}`);
  console.log(`준우승 : ${second}`);
  for (const arg of others) {
    console.log(`참가자: ${arg}`);
  }
}

printRank('Phil', 'Won', 'Emma', 'Min', 'Luke');
```

실제로 Rest Parameter가 더욱 강력하게 사용되어지기 때문에 사용하는 것을 권장한다.

## this
만약 그냥 console.log에 this 객체를 넣게 되면 window 객체를 사용한 것으로 나오게 된다. 

일반함수와 arrow function의 this함수를 다루는게 다르다. 
arrow function의 this 값은 arrowfunction이 선언되기 직전의 this값과 똑같은 값을 보여준다.

그래서 this fucntion을 사용하기 위해서는 일반function을 사용하는 것이 더욱 효과적이다.

## 문장과 표현식
우리가 작성하는 모든 자바스크립트 코드는 모두 문장과 표현식으로 구성되어 있습니다. 
### 문장(statement)
먼저, 자바스크립트에서 문장은 어떤 동작이 일어나도록 작성된 최소한의 코드 덩어리를 가리킵니다.
### 표현식(expressions)
결과적으로 하나의 값이 되는 모든 코드를 가리킨다.

객체의 프로퍼티에 접근하는 것도 결국에는 하나의 값으로 평가가 되는데 그래서 길이와는 상관없이 결과적으로 하나의 값이 되는 코드를 모두 표현식이라고 할 수가 있습니다.

## 표현식이면서 문장, 문장이면서 표현식
표현식은 보통 문장의 일부로 쓰이지만, 그 자체로 문장일 수도 있습니다. 가장 대표적인 예시가 할당식과 함수 호출입니다.
title = 'javascript' -> 할당 연산자는 값을 할당하는 동작도 하지만, 할당한 값을 가지는 표현식이다.
sayHi(); 함수 호출은 함수를 실행하는 동작도 하지만, 실행한 함수의 리턴값을 가지는 표현식이다.
console.log() 콘솔에 argument를 출력하는 동작도 하지만, undefined값을 가지는 표현식이다.

자바스크립트에서 특별한 경우를 제외한다면 일반적으로 표현식인 문장은 세미콜론으로, 표현식이 아닌 문장은 문장 자체의 코드 블로으로 그 문장의 범위가 구분이 되어진다.

## node
### 자바스크립트 런타임
특정 언어로 마든 프로그램들을 실행 할 수 있는 환경을 의미합니다.
### 이벤트 기반
이벤트가 발생했을 때 미리 지정해둔 작업을 수행하는 방식을 의미합니다.
특정 이벤트가 발생할 때 무엇을 할지 미리 등록을 해두어야 합니다. 이를 **이벤트 리스너에 콜백 함수를 등록한다** 라고 표현합니다.

노드 역시 이벤트 기반으로 동작하므로 이벤트가 발생하면 이벤트 리스너에 등록해둔 콜백함수를 호출 합니다. 이벤트를 다 처리하면 노드는 다음 이벤트 발생 할때 까지 대기 합니다.

----
### 이벤트 루프
이벤트 발생 시 호출할 콜백 함수들을 관리하고, 호출된 콜백 함수의 실행 순서를 결정하는 역활을 담당합니다. 노드가 종료될 때까지 이벤트 처리를 위한 작업을 반복하므로 루프(loop)라고 합니다.
### 백그라운드
이벤트 리스너 들이 대기하는 공간, 여러작업이 동시에 실행 가능
### 태스크 큐
이벤트 발생후, 백그라운드에서는 태스크 큐로 타이머나 이벤트 리스너의 콜백함수를 보냄

---

자바스크립트 코드는 동시에 실행이 될 수 없다. 하지만 자바스크립트 상에서 돌아가는 것이 아닌 I/O 작업 같은 것은 동시에 처리될 수 있습니다.

I = Input
O = Output

파일 시스템 접근 - 논 블로킹
>논 블로킹
이전 작업이 완료될 때까지 대기하지 않고 다음 작업을 수행함
블로킹
이전 작업이 끝나야만 다음 작업을 수행

### 싱글 스레드
노드는 싱글스레드
노드를 실행하면 먼저 프로세스가 하나 생성이 됩니다. 그리고 그 프로세스에서 내부적으로 여러개의 스레드를 생성하는데 사용자는 그 중 한 개의 스레드만을 제어할 수 있습니다.

#### 노드에서의 멀티 스레드 vs 멀티 프로세싱
식당을 예로 들게 되면 한명의 점원이 주방에 주문을 받고 주문을 넣고 음식이 나오는 순서대로 가져다 줍니다. 노드는 이런 방식을 사용합니다. 이걸 싱글스레드 논 블로킹 모델이라고 할 수있습니다. 하지만 그 점원이 쓰러지게 되면 큰 문제가 생기게 됩니다. 요리를 하는데 오래걸린다(cpu를 많이 쓰이는 작업)면 버거울 수 있습니다.

멀티 스레드는 고객 한명당 점원 한 명씩을 할당해서 운영하는 것입니다. 얼핏 보면 이게 더 좋아보일 수도 있으나 손님의 수가 늘어나면 점원의 수가 늘어나게 되고, 손님 수가 줄어 들었을 때 노는 점원이 노는 점원이 있을 것이고 비용의 증가가 일어나게 됩니다.

|멀티 스레딩|멀티 프로세싱|
|--------|-----------|
|하나의 프로세스안에서 여러개의 스레드 사용|여러개의 프로세스 사용|
|CPU작업이 많을 때 사용|I/O의 요청이 많을 때 사용|
|프로그래밍이 어려움|프로그래밍이 비교적 쉬움|

## 노드.js
- 서버에는 기본적으로 I/O의 요청이 많이 발생하므로, I/O 처리를 잘하는 노드를 서버로 사용하면 좋습니다. 
- 노드는 CPU 부하가 큰 작업에는 적합하지 않습니다. CPU연산을 많이 요구하면 스레드 하나가 혼자서 감당하기 어렵습니다.
- 개수는 많지만 크기는 작은 데이터를 실시간으로 주고받는데 적합합니다.
- 이미지나 비디오 처리, 혹은 대규모 데이터 처리처럼 CPU를 많이 사용하는 작업을 위한 서버로는 권장하지 않습니다. AWSlambda, google cloud functions 같은 서비스에서 노드로 CPU를 많이 사용하는 작업을 처리하는 것을 지원하므로 고려
- 싱글 스레드 방식으로 서버를 운영할때는 하나뿐인 스레드가 에러로 인해 멈추지 않도록 잘 관리해야 합니다.

## REPL(Read, Eval, Print, Loop)
입력한 코드를 읽고, 해석하고, 결과물을 반환하고, 종료할때 까지 반복한다. -> django shell 느낌

>#### 모듈
특정한 기능을 하는 함수나 변수들의 집합, 모듈은 자체로도 하나의 프로그램이면서 다른 프로그램의 부품으로도 사용할 수 있다.

### console
보통 디버깅을 위해 사용합니다. 변수에 값이 제대로 들어 있는지, 에러발생 시 에러 내용을 콘솔에 표현하기 위해서, 코드 실행 시간을 알아보려고 할 때도 사용합니다.

console.time: console.timeEnd과 대응되어 같은 레이블을 가진 time과 timeEnd 사이의 시간을 측정합니다.

console.log('내용'): 평범한 로그를 콘솔에 표시합니다. console.log(내용, 내용)처럼 여러 내요을 동시에 표현할 수 있습니다.

console.error(에러 내용): 에러를 콘솔에 표시합니다.
console.table(배열): 배열의 요소로 객체 리터럴에 넣으면, 객체의 속성들이 테이블 형식으로 표현됩니다. 아래 결과를 확인해 보세요

console.dir(객체, 옵션): 객체를 콘솔에 표시할 때 사용합니다. 첫 번째 인수로 표시할 객체를 넣고, 두 번째 인수로 옵션을 넣습니다. 옵션의 colors를 true로 하면 콘솔에 색이 추가되어 
채보기가 한결 편해 집니다. depth는 객체 안의 객체를 몇 단계 까지 보여줄지를 결정합니다. 기본값은 2입니다.

console.trace(레이블): 에러가 어디서 발생했는지 추적할 수 있게 합니다. 일반적으로 에러 발생 시 에러 위치를 알려주므로 자주 사용하지는 않지만, 위치가 나오지 않는 다면 사용할 만 합니다.

## this
```js
function hello () {
  console.log(this);
  console.log(this === global);
}

hello();


class A {
  constructor(num) {
     this.num = num;
  }
  memberFunction() {
    console.log('------class--------------');
    console.log(this);
    console.log(this === global);
  }
}

const a = new A(1);
a.memberFunction();
```
hello 함수의 this는 global을 가리키고 있으며
클래스의 this는 클래스 안에 있는 1을 가리키고 있습니다.


## module, exports, require
처음에 모듈을 작성할 때
```js
const odd = '홀수입니다.'
const even = '짝수입니다.'

module.exports = {
 odd,
 even
}
```

이런식으로 모듈을 만들어 주었습니다.

```js
exports.odd = '홀수입니다.';
exports.even = '짝수입니다.';
```
이렇게 수정해도 사용이 가능합니다.

가능한 이유
- module.exports와 exports가 같은 객체를 참조하기 때문입니다.
- module.exports에는 어떤 값이라도 대응이 가능하지만, exports에는 객체처럼 속성명과 속성값만이 대응이 가능하다. 
module.exports에 함수를 대응하게 되면 exports는 사용이 불가능 하다.
- module.exports와 exports는 동시에 사용하지 않는 편이 좋다.

console.log(module.exports === exports) 하면 true가 나온다.


>require와 exports
require와 exports는 맨 위에 오지 않아도 사용이 가능하다.

```js
module.exports.getCount = getCount;
exports = {}
exports.increase = increase;
```

그래서 처음과 두번째의 module.exports === exports를 비교 해보면 결과값이 다르게 나오는 것을 확인 할 수 있습니다.

이 부분은 예전 버전이고 ES6이후부터는 자바스크립트 자체적으로 import 기능을 지원하고 있습니다.

#### 자바스크립트 자체적인 import 방법
터미널에 **npm init --yes** 를 입력하게 되면 package.json이 생기게 됩니다. 그 폴더에 들어가서 **"type" : "module",**을 입력해줘야 하는데 이는 module을 import 할때 자바스크립트에서 자체적으로 지원해주는 방법을 쓰겠다고 말하는것이다.

그럼 모듈을 import 하는 방법에서도
```js
export function increase() {
  count++;
}
```
export를 이런식으로 해주면 되고
require 부분에서도

let count = require('./counter')

**import {increase, getCount} from './counter'**

이런식으로 적어주면 된다.
그리고 기존의
counter.increase();   -> increase();
counter.getCount();   -> getCount();

#### nextTick()
콜백함수에 어떤 다른 함수가 있더라도 무시하고 taskque 제일 앞부분에 콜백함수를 넣어준다.

#### setTimeout()
함수가 다실행이 되고 나서 몇 초뒤에 내 콜백 함수를 실행해 달라고 요청하는 것을 의미한다.

## 버퍼와 스트림(Buffer and Stream)
스트림 : 데이터를 잘게 쪼개서 전송하는 것

파일을 조금씩 읽으면서 전송을 한다.



